---
# This template is licensed under a Creative Commons 0 1.0 Universal License (CC0 1.0). Public Domain Dedication.

title: 'Kabelsalat: Live Coding Audiovisual Graphs on the Web and Beyond'
author:
  - name: Felix Roos
    affiliation: Unaffiliated
    email: flix91@gmail.com
  - name: Raphaël Maurice Forment
    affiliation: Université Jean Monnet
    email: raphael.forment@gmail.com
abstract: |
  This paper introduces Kabelsalat, a graph-based live coding environment that targets multiple platforms and languages. It works by translating a Domain Specific Language (DSL) into a signal flow graph. This graph can be compiled into a sequence of instructions optimized for real time signal processing. The DSL has been implemented both in JavaScript and Lua. The compiler can either output JavaScript code to run in the browser or optimized C code to run natively. The possibility of adding other target languages is an integral part of KabelSalat's design. The browser version includes a REPL and features a range of audio DSP nodes reminiscent of modular synthesizers. Notable features include single sample feedback and multi-channel expansion inspired by the SuperCollider audio engine. The core module of Kabelsalat has also been used to implement a stripped down version of the Hydra video synthesizer, thus demonstrating that the same underlying principles can be adapted both for audio and video generation. In the future, KabelSalat might become an alternative audio engine for Strudel, offering more sound design capabilities, compared to the current superdough engine, which uses the browser's built-in Web Audio Nodes.
fontsize: 11pt
geometry: margin=2cm
fontfamily: libertine
fontfamily: inconsolata
mainfont: Linux Libertine
monofont: Inconsolata
bibliography: references.bib
...

# Introduction

Graphs are often used to represent the signal flow of live coding systems, as demonstrated by Glicol [@glicol],
Genish.js [@Roberts17], Hydra [@hydra] or Punctual [@punctual]. This type of representation is also common for live patching environments such as NoiseCraft [@noisecraft], cables.gl [@cables.gl] or VCVRack. In this context, graphs often feel more natural, as they allow for a more direct and graphical representation of the signal flow.
Many important audio programming languages from the past decades, such as Pure Data [@puredata] and SuperCollider [@supercollider], are also computing audio based on the concept of signal flow graphs. Graphs often allow for an optimized execution of the signal processing chain, as they can be analyzed and optimized before execution.

Nowadays, this dataflow paradigm is getting increasingly more common in the context of web audio. One can notice a gradual shift from the usage of built-in Web Audio nodes^[] to the more recently introduced AudioWorklets [@Choi2018AudioworkletTF;@Roberts18]. AudioWorklets allow the creation of self-contained signal processors, less dependant on web platform specifics. These can be developed in JavaScript and/or compiled to WebAssembly from any other language supporting this compilation target. Furthermore, they introduce a significant advantage over built-in web audio nodes. Audioworklets can be used to implement DSP algorithms that rely on single-sample processing. This property offers many advantages over block-based processing such as the possibility of writing audio feedback loops or granular synthesis algorithms [@Roberts17]. Single-sample processing also removes the block size constraint of web audio nodes, which can be a constraint for some algorithms (EXAMPLES).

The creative exploration of the technical possibilities offered by AudioWorklets was the initial motivation to build an audio engine that could eventually be used in Strudel [@strudel]. For the time being, Strudel uses the more limited built-in Web Audio graph for its audio engine called _superdough_^[].

_Kabelsalat_ implements a Domain Specific Language (DSL) to represent and compile graphs suitable for single-sample processing. The compilation strategy, as well as many audio nodes of Kabelsalat, are based on the browser-based NoiseCraft [@noisecraft] synthesizer. The NoiseCraft compiler was rewritten to a version that encapsulates its core logic from the output language, allowing each node to control its own code generation. With this addition, the core language is not specifically tied to audio graphs or a single output language.  To test the viability of compiling to another language, Kabelsalat can also compile a graph to C code, to be played as a standalone binary. As another proof-of-concept, Kabelsalat was used to compile Hydra [@hydra] patches to GLSL code, showing an application of the same concepts in another domain.

<!-- # System Overview

```
User -> DSL -> Graph -> Compiler -> Code+Metadata -> Runtime
```
 -->

# Introducing the Kabelsalat DSL

KabelSalat provides a terse and practical syntax for writing audio graphs on-the-fly. Moreover, many syntactic shortcuts have been developed to make the code more readable while also being easier to write. KabelSalat's DSL
is designed to be expressive. The following example, as a first introduction, shows how a simple subtractive synthesis patch can be written:

```js
// sawtooth wave at 55Hz:
saw(55)
  // modulated low-pass-filter
  .lpf(sine(1).range(0.4, 0.8))
  // modulated amplitude:
  .mul(sine(4).range(0.25, 1))
  // send to output:
  .out();
```

This type of syntax corresponds metaphorically to the operation of a modular synthesizer, whose signal generation and processing is organized into several modules, represented by function calls. Each function call creates a node, given its inputs as arguments. Each argument can be either a constant value or another node, which allows creating patches of arbitrary depth. Figure 1 shows the example's graphical representation, which was created by Kabelsalat's visualizer.

![Graph visualization of a sawtooth wave with filter and amplitude modulation](images/figure1.svg)

## Method Chaining

As demonstrated in the previous example, Kabelsalat employs method chaining to "flatten" the syntax.
The same example can be expressed without method chaining as well:

```js
// send to output:
out(
  // modulate amplitude
  mul(
    // modulated low-pass-filter
    lpf(
      // sawtooth wave at 55Hz:
      saw(55),
      range(sine(1), 0.4, 0.8)
    ),
    range(sine(2), 0.25, 1)
  )
);
```

This notation only consists of function calls, which is syntactically simpler, but arguably more difficult to parse as a human. Compared to the method chaining example, the expression is deeply nested, with a wider distance between logically grouped tokens. Additionally, editing the expression involves a lot of extra indenting and cursor movement.
To avoid these difficulties, Kabelsalat includes method chaining, similar to Hydra [@hydra] and Strudel [@strudel].
Method chaining can be seen as a way to write expressions in the same order as infix notation, without the need to overload operators. When a method is called on a node, that node is used as the first input of the method.

## Multichannel Expansion

Inspired by SuperCollider, Kabelsalat allows expanding the channels of a graph by passing an Array to a node:

```js
// create two channels of filtered sawtooth waves
saw([200, 300]).lpf(0.5).out([0, 1]);
```

Multichannel expansion [@multichannelexpansion] simplifies writing and editing graphs that represent multiple signal channels.
It allows generating large graphs with relatively few characters.
In Kabelsalat, it works as follows:
The Array is interpreted as a special `poly` node, where each element of the Array is an input.
When a node receives a `poly` node with `n` inputs, `n` copies of the node are created.
Each copy receives one of the values in the Array.
The copied nodes are fed into a new `poly` node, which is propagated down the graph.
The `poly` node will eventually end up at the bottom of the graph, where each channel is assigned to one `out` node.
In cases where a node receives multiple `poly` nodes, the `poly` node with the most inputs determines the number of copies.
The inputs of the other `poly` nodes wrap around.

Figure 2 shows a graphical version of how the `poly` node is propagated in the above example.

The end result of the expansion is equivalent to:

```js
// the above is equivalent to:
saw(200).lpf(0.5).out(0);
saw(300).lpf(0.5).out(1);
```

![Multichannel Expansion Example](images/mch.png)

## Feedback

A feedback loop is created when a node uses its own output as an input, creating a cycle in the graph.
For both audio and video synthesis, feedback plays an important role for a variety of techniques [@Roberts17]. Kabelsalat supports single sample feedback, which can be notated in 2 ways:

1. Passing an anonymous function as a function argument
2. Using the `src` node to read from an output

### Feedback with Anynomous Functions

An anonymous function can be passed to any node to create a cycle:

```js
impulse(1)
  .add((x) => x.delay(0.2).mul(0.8))
  .out();
```

In this example, the `add` node receives an anonymous function as its input, which receives its own output as an argument. This allows notating the transformsations of the feedback loop within that function. Figure 3 shows a graph visualization of this example.

![Graph visualization of a simple feedback delay](images/feedback.svg)

### Feedback with `src` Node

Instead of using an anonymous function, feedback can also be created with the dedicated `src` node:

```js
impulse(1).add(src(0).delay(0.1).mul(0.8)).out();
```

This syntax is inspired by Hydra [@hydra], where feedback is also created using `src` and `out` nodes.

# Graph Compilation

After a brief introduction of the language, this chapter explains how it is compiled into a representation that is optimized to run within the constraints of a real-time system. Note that the following examples are specifically targetting audio synthesis in JavaScript. Compilation to C or GLSL follows similar principles.

## From DSL to Graph

When the DSL is evaluated, a directed graph is created. As a TypeScript interface, the structure of a `Node` can be described as:

```ts
interface Node {
  type: string;
  ins: Array<Node | number>;
}
```

Each `Node` has a type and an Array of inputs called `ins`.
Elements inside `ins` are either other instances of `Node` or constant numeric values.
Here is an example of a `Node` instance representing a filtered sawtooth wave:

```json
{
  "type": "out",
  "ins": [{ "type": "lpf", "ins": [{ "type": "saw", "ins": [200] }, 0.5] }, 0]
}
```

Note that the above data is represented as json only for the purpose of readability. The actual implementation uses JavaScript Objects, where each `Node` is only referenced, meaning reused `Node` instances will not be copied. For cyclical graphs, a JSON representation does not exist, because it would create an infinite loop.

## From Graph to Output Language

To generate efficient runtime code, the graph is converted into a sequence of steps.
Before compilation, `Nodes` are sorted topologically, making sure each `Node`'s inputs are computed first.
The compiler output for the graph of the last example is as follows:

```js
r[1] = nodes[0].update(200); /* saw */
r[3] = nodes[1].update(r[1], 0.5, 0); /* lpf */
o[0] = r[3]; /* out 0 */
```

In an AudioWorklet [@Choi2018AudioworkletTF], this code will run once for each sample, typically at 44,1kHz or 48kHz.
Each `Node` corresponds to one line in the generated code. It expects the following variables to be defined:

- `nodes`: instances of stateful nodes
- `r`: node value registers
- `o`: output channel registers

### Stateful Nodes

The `nodes` Array contains instances of stateful signal processors, which are expected to be provided to the compiled function.
Stateful nodes are essential for many audio DSP techniques, for example to keep track of the phase of an oscillator while its frequency is being modulated. Each audio processor needs to implement an `update` method to compute the next sample based on its input arguments.
A simple sawtooth wave can be implemented in JavaScript as follows:

```js
class SawOsc {
  constructor() {
    this.phase = 0;
  }
  update(freq) {
    this.phase += SAMPLE_TIME * freq;
    return (this.phase % 1) * 2 - 1;
  }
}
```

In the C language, a similar pattern can be implement with an update function operating on a struct.
In GLSL, nodes are stateless due to the parallel nature of graphics rendering.

### Value Registers

The `r` Array contains the latest output values of each `Node`.
When a graph contains cycles, the node that receives the feedback depends on a node that has not been calculated yet.
By saving each `Node`'s result into the `r` Array, those nodes will automatically receive the value from the previous iteration.
To illustrate this point, here is the compiled output of Figure 3:

```js
r[1] = nodes[0].update(1); /* impulse */
r[3] = nodes[1].update(r[6], 0.2); /* delay */
r[5] = r[3] * 0.8; /* mul */
r[6] = r[1] + r[5]; /* add */
o[1] = r[6]; /* out 1 */
o[0] = r[6]; /* out 0 */
```

In Line 2, `r[6]` references the value of the previous iteration, making feedback possible.

### Output Registers

The `o` Array keeps track of each output channel.
After each iteration of the compiled sequence, `o[0]` and `o[1]` can be passed to the sound card for playback.
The `out` function of the DSL takes a channel as its only argument, which falls back to `[0,1]`.
This ensures both stereo channels receive a value by default.

## Node Compilation

To encapsulate the compiler logic from the output language, each node definition contains a `compile` function that is expected to output its target language. The compiler's sole responsibility is to pass the correct register names and constant values to the compile function. An `impulse` node could be defined to output C code as:

```js
let saw = registerNode("impulse", {
  ugen: "ImpulseOsc",
  compile: ({ vars: [freq = 0], name, node, ugen }) =>
    `${name} = ${ugen}_update(${node},${freq}); /* ${ugen} */`,
});
```

In comparison to the JavaScript version, the C version of Figure 3 is:

```c
r[1] = ImpulseOsc_update(nodes[0],1); /* ImpulseOsc */
r[3] = Delay_update(nodes[1],r[6],0.2); /* Delay */
r[5] = r[3] * 0.8;
r[6] = r[1] + r[5];
o[0] = r[6]; /* out 0 */
o[1] = r[6]; /* out 1 */
```

# References
