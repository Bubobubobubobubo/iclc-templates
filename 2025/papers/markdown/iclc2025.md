---
# This template is licensed under a Creative Commons 0 1.0 Universal License (CC0 1.0). Public Domain Dedication.

title: 'Kabelsalat: Live Coding Audiovisual Graphs on the Web and Beyond'
author:
  - name: Felix Roos
    affiliation: Unaffiliated
    email: flix91@gmail.com
abstract: |
  This paper introduces Kabelsalat, a graph-based live coding environment that targets multiple platforms and languages. It works by translating a Domain Specific Language (DSL) into a data flow graph, to finally be compiled into a sequence of instructions optimized for real time signal processing. The DSL has been implemented both in JavaScript and Lua. Currently, the compiler output can either be optimized JavaScript to run in the browser, or optimized C code to run natively. Being able to add other output languages in the future is part of the design. The Browser version includes a REPL that implements a range of audio DSP nodes that are reminiscent of a modular synthesizer. Notable features include single sample feedback and multi-channel expansion, inspired by SuperCollider. The core module of kabelsalat has also been used to implement a stripped down version of the Hydra video synthesizer, applying the same principles to generate GLSL code. In the future, kabelsalat might become an alternative audio engine of strudel, offering more sound design capabilities, compared to the current superdough engine, which uses the browser's built-in Web Audio Nodes.
fontsize: 11pt
geometry: margin=2cm
fontfamily: libertine
fontfamily: inconsolata
mainfont: Linux Libertine
monofont: Inconsolata
bibliography: references.bib
...

# Introduction

Graphs are an abstraction to represent the signal flow of many live coding systems, such as SuperCollider [@supercollider], Glicol [@glicol], Genish.js [@Roberts17], Hydra [@hydra], and Punctual [@punctual]. They are also ideal for patcher interfaces, such as Pure Data [@puredata], NoiseCraft [@noisecraft] and cables.gl [@cables].
In Web Audio specifically, there has been a shift from using the built-in Web Audio nodes to the more recently introduced AudioWorklets [@Choi2018AudioworkletTF;@Roberts18]. AudioWorklets allow writing signal processors that are self-contained, without being too intertwined with web platform specifics. Furthermore, they can be used to implement DSP algorithms that rely on single-sample processing, which is not possible in the block based processing model of the Web Audio API graph [@Roberts17]. These properties were the initial motivation to build an audio engine that could eventually be used in Strudel [@roos_2023_7842142]. For the time being, Strudel uses the more limited built-in Web Audio graph for its audio engine called _superdough_. _Kabelsalat_ implements a Domain Specific Language (DSL) to represent and compile graphs suitable for single-sample processing. Each node can define its compiler output, which means the core language is not specifically tied to audio graphs or the host language of the DSL.
To test the viability of compiling a graph to another language, Kabelsalat can also compile a graph to C code, to be played as a standalone binary. As another proof-of-concept, Kabelsalat was used to compile Hydra [@hydra] patches to GLSL code, showing how the same concepts apply in the visual domain.

# Introducing the Kabelsalat DSL

This is a simple example of how to do subtractive synthesis in Kabelsalat:

```js
// sawtooth wave at 55Hz:
saw(55)
  // modulated low-pass-filter
  .lpf(sine(1).range(0.4, 0.8))
  // modulated amplitude:
  .mul(sine(4).range(0.25, 1))
  // send to output:
  .out();
```

This piece of JavaScript code represents the signal flow of an audio graph, including oscillators, filters and modulations.
It can be seen analogous to the operation of a modular synthesizer.
Each function call creates a node, given its inputs as arguments.
Figure 1 shows a graph visualization of this example.

![Graph visualization of a sawtooth wave with filter and amplitude modulation](images/figure1.svg)

## Method Chaining

As demonstrated in the previous example, Kabelsalat employs method chaining to "flatten" the syntax.
The above example can also expressed without method chaining like this:

```js
// send to output:
out(
  // modulate amplitude
  mul(
    // modulated low-pass-filter
    lpf(
      // sawtooth wave at 55Hz:
      saw(55),
      range(sine(1), 0.4, 0.8)
    ),
    range(sine(2), 0.25, 1)
  )
);
```

This notation only consists of function calls, which is syntactically simpler, but arguably more difficult to parse as a human. Compared to the method chaining example, the expression here is deeply nested, with a wider distance between logically grouped tokens. Additionally, editing the expression involves a lot of extra indenting and cursor movement.
To avoid these difficulties, Kabelsalat includes method chaining, similar to Hydra and Strudel.
Method chaining can be seen as a way to write expressions in the same order as infix notation, without the need to overload operators. When a method is called on a node, that node is used as the first input of the method.

## Multichannel Expansion

Inspired by SuperCollider, Kabelsalat allows expanding the channels of a graph by passing an Array to a Node:

```js
// create two channels of filtered sawtooth waves
saw([200, 300]).lpf(0.5).out([0, 1]);
```

Multichannel expansion allows generating larger graphs with relatively few characters.
In Kabelsalat, it works as follows:
The Array is interpreted as a special `poly` node, where each element of the Array is an input.
When a node receives a `poly` node, it is split into multiple versions of itself.
Each version receives one of the values in the Array.
The split nodes are fed into a new `poly` node, which is propagated down the graph.
The `poly` node will eventually end up at the bottom of the graph, where each channel is assigned to one `out` node.

Figure 2 shows a graphical version of how the `poly` node is propagated in the above example.

The end result of the expansion is equivalent to:

```js
// the above is equivalent to:
saw(200).lpf(0.5).out(0);
saw(300).lpf(0.5).out(1);
```

![Multichannel Expansion Example](images/mch.png)

## Feedback

A feedback loop is created when a node uses its own output as an input, creating a cycle in the graph.
For both audio and video synthesis, feedback plays an important role for a variety of techniques. Kabelsalat supports single sample feedback, which can be notated in 2 ways:

1. Passing an anonymous function as a function argument
2. Using the `src` node to read from an output

### Feedback with Anynomous Functions

An anonymous function can be passed to any node to create a cycle:

```js
sine(200)
  // amplitude envelope
  .mul(impulse(1).ad(0, 0.1))
  // feedback delay
  .add((feedback) => feedback.delay(0.1).mul(0.8))
  .out();
```

In this example, the `add` node receives an anonymous function as its input, which receives its own output as an argument. This allows notating the transformations of the feedback loop within that function. Figure 3 shows a graph visualization of this example.

![Graph visualization of a simple feedback delay](images/figure3.svg)

### Feedback with `src` Node

Instead of using an anonymous function, feedback can also be creating with the dedicated `src` node:

```js
sine(200)
  // amplitude envelope
  .mul(impulse(1).ad(0, 0.1))
  // feedback delay
  .add(src(0).delay(0.1).mul(0.8))
  .out();
```

This syntax is inspired by Hydra, where feedback is also created using `src` and `out` nodes.

# Graph Compilation

After a brief introduction of the language, this chapter explains how it is compiled into a representation that is optimized to run within the constraints of a real-time system.

## From DSL to Graph

When the DSL is evaluated, a directed graph is created. As a TypeScript interface, the structure of a `Node` can be described as:

```ts
interface Node {
  type: string;
  ins: Array<Node | number>;
}
```

Each `Node` has a unique type and an Array of inputs called `ins`.
Elements inside `ins` are either other instances of `Node` or constant numeric values.
Here is an example of a very simple audio graph:

```js
saw(200).lpf(0.5).out();
```

The corresponding `Node` looks like this:

```json
{
  "type": "out",
  "ins": [{ "type": "lpf", "ins": [{ "type": "saw", "ins": [200] }, 0.5] }, 0]
}
```

Note that the above data is represented as json only to aid readability. The actual implementation uses JavaScript Objects, where each `Node` is only referenced, meaning reused `Node` instances will not be copied.

## From Graph to Output Language

To generate efficient runtime code, the graph is converted into a sequence of steps.
`Nodes` are sorted in topological order, making sure each `Node`'s inputs are already computed at the time it is processed.
When compiling to JavaScript, the graph of the last example generates the following code:

```js
r[1] = nodes[0].update(200); /* saw */
r[3] = nodes[1].update(r[1], 0.5, 0); /* lpf */
o[0] = r[3]; /* out 0 */
o[1] = r[3]; /* out 1 */
```

In the case of audio synthesis, this code will run once for each sample, typically at 44,1kHz or 48kHz.
Each `Node` corresponds to one line in the generated code. It expects the following variables to be defined:

- `nodes`: instances of stateful nodes
- `r`: node value registers
- `o`: output channel registers

### Stateful Nodes

The `nodes` Array contains instances of stateful signal processors. They are expected to be provided to the compiled function.
Each processor needs to implement an `update` method, which receives the `Node` inputs as arguments. A simple sawtooth wave can be implement as follows:

```js
class SawOsc {
  constructor() {
    this.phase = 0;
  }
  update(freq) {
    this.phase += SAMPLE_TIME * freq;
    return (this.phase % 1) * 2 - 1;
  }
}
```

### Value Registers

The `r` Array contains the latest output values of each `Node`.
When a graph contains cycles, the node that receives the feedback depends on a node that has not been calculated yet. By saving each `Node`'s result into the `r` Array, those nodes will automatically receive the value from the previous iteration.
To illustrate this point, here is a simple feedback example:

```js
impulse(1)
  .add((x) => x.delay(0.2).mul(0.8))
  .out();
```

The compiled output looks like this:

```js
r[1] = nodes[0].update(1, 0); /* impulse */
r[3] = nodes[1].update(r[6], 0.2); /* delay */
r[5] = r[3] * 0.8; /* mul */
r[6] = r[1] + r[5]; /* add */
o[1] = r[6]; /* out 1 */
o[0] = r[6]; /* out 0 */
```

In Line 2, `r[6]` references the value of the previous iteration, making feedback possible.

![Feedback Example](images/feedback.svg)

### Output Registers

The `o` Array keeps track of each output channel.
After each iteration of the compiled sequence, `o[0]` and `o[1]` can be passed to the sound card for playback.

# References
